#!/usr/bin/env python3
"""
Opening-book tournament: v20_engine vs v19_engine at fixed depth.

For each of X random opening positions (generated by playing N random moves
from startpos), both engines play both colors. Results are aggregated.

Usage:
  python3 tournament_openings.py [--openings N] [--depth D] [--moves M]
                                  [--opening-plies P] [--benchmark]
                                  [--seed S]

  --openings N      Number of opening positions (default: auto-timed)
  --depth D         Search depth for both engines (default: 10)
  --moves M         Max half-moves per game before draw (default: 200)
  --opening-plies P Random moves to play before starting (default: 10)
  --benchmark       Time 2 games and report seconds/game, then exit
  --seed S          Random seed for reproducibility (default: 42)
  --hours H         Target hours for auto X calculation (default: 7.5)
"""

import argparse
import chess
import chess.pgn
import io
import os
import random
import subprocess
import sys
import time

ENGINE_V20 = "./v20_engine"
ENGINE_V19 = "./v19_engine"

# ── UCI engine wrapper ────────────────────────────────────────────────────────

class Engine:
    def __init__(self, path, name):
        self.name = name
        self.proc = subprocess.Popen(
            [path],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True, bufsize=1,
        )
        self._send("uci")
        self._read_until("uciok")
        self._send("ucinewgame")
        self._send("isready")
        self._read_until("readyok")

    def _send(self, cmd):
        self.proc.stdin.write(cmd + "\n")
        self.proc.stdin.flush()

    def _read_until(self, token):
        lines = []
        while True:
            line = self.proc.stdout.readline().strip()
            if line:
                lines.append(line)
            if token in line:
                return lines

    def get_move(self, fen, depth):
        self._send(f"position fen {fen}")
        self._send(f"go depth {depth}")
        lines = self._read_until("bestmove")
        for line in lines:
            if line.startswith("bestmove"):
                parts = line.split()
                if len(parts) >= 2 and parts[1] not in ("(none)", "0000"):
                    return parts[1]
        return None

    def new_game(self):
        self._send("ucinewgame")
        self._send("isready")
        self._read_until("readyok")

    def quit(self):
        try:
            self._send("quit")
            self.proc.wait(timeout=3)
        except Exception:
            self.proc.kill()


# ── Opening generation ────────────────────────────────────────────────────────

def generate_opening(plies, rng):
    """Play `plies` random legal moves from startpos. Return FEN."""
    board = chess.Board()
    for _ in range(plies):
        legal = list(board.legal_moves)
        if not legal:
            break
        move = rng.choice(legal)
        board.push(move)
        if board.is_game_over():
            board.pop()
            break
    return board.fen()


# ── Single game ───────────────────────────────────────────────────────────────

def play_game(white_engine, black_engine, start_fen, depth, max_moves):
    """
    Play one game from start_fen.
    Returns: 1.0 (white wins), 0.5 (draw), 0.0 (black wins)
    """
    board = chess.Board(start_fen)

    for _ in range(max_moves):
        if board.is_game_over(claim_draw=True):
            break
        engine = white_engine if board.turn == chess.WHITE else black_engine
        move_uci = engine.get_move(board.fen(), depth)
        if move_uci is None:
            break
        try:
            move = chess.Move.from_uci(move_uci)
        except ValueError:
            break
        if move not in board.legal_moves:
            break
        board.push(move)

    result = board.result(claim_draw=True)
    if result == "1-0":
        return 1.0
    elif result == "0-1":
        return 0.0
    else:
        return 0.5


# ── Main ──────────────────────────────────────────────────────────────────────

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--openings",      type=int,   default=0)
    parser.add_argument("--depth",         type=int,   default=10)
    parser.add_argument("--moves",         type=int,   default=200)
    parser.add_argument("--opening-plies", type=int,   default=10, dest="plies")
    parser.add_argument("--benchmark",     action="store_true")
    parser.add_argument("--seed",          type=int,   default=42)
    parser.add_argument("--hours",         type=float, default=7.5)
    args = parser.parse_args()

    rng = random.Random(args.seed)

    print(f"Starting engines...", flush=True)
    v20 = Engine(ENGINE_V20, "v20")
    v19 = Engine(ENGINE_V19, "v19")
    print(f"  v20: {ENGINE_V20}", flush=True)
    print(f"  v19: {ENGINE_V19}", flush=True)
    print(f"  Depth: {args.depth}  Max half-moves: {args.moves}  Opening plies: {args.plies}", flush=True)

    # ── Benchmark: time 2 games, report and exit ──────────────────────────────
    if args.benchmark:
        print("\nBenchmark mode: timing 2 games (1 opening, both colors)...", flush=True)
        fen = generate_opening(args.plies, rng)
        print(f"  Opening FEN: {fen}", flush=True)

        t0 = time.time()
        r1 = play_game(v20, v19, fen, args.depth, args.moves)
        v20.new_game(); v19.new_game()
        r2 = play_game(v19, v20, fen, args.depth, args.moves)
        elapsed = time.time() - t0

        v20.quit(); v19.quit()
        print(f"  Game 1 (v20=W): {r1}", flush=True)
        print(f"  Game 2 (v20=B): {1.0 - r2}", flush=True)
        print(f"  Time for 2 games: {elapsed:.1f}s  ({elapsed/2:.1f}s/game)", flush=True)
        secs_per_pair = elapsed

        for target_h in [7.5, 8.0]:
            x = int(target_h * 3600 / secs_per_pair * 0.92)  # 8% buffer
            print(f"  Openings for {target_h}h: ~{x}", flush=True)
        return

    # ── Auto-calculate openings if not specified ──────────────────────────────
    if args.openings == 0:
        print("\nAuto-timing: running 1 opening pair to estimate speed...", flush=True)
        fen = generate_opening(args.plies, rng)
        t0 = time.time()
        play_game(v20, v19, fen, args.depth, args.moves)
        v20.new_game(); v19.new_game()
        play_game(v19, v20, fen, args.depth, args.moves)
        secs_per_pair = time.time() - t0
        args.openings = max(1, int(args.hours * 3600 / secs_per_pair * 0.92))
        print(f"  {secs_per_pair:.1f}s per opening pair → {args.openings} openings for {args.hours}h", flush=True)
        rng = random.Random(args.seed)  # reset so openings are reproducible

    # ── Generate all opening positions up-front ───────────────────────────────
    print(f"\nGenerating {args.openings} opening positions ({args.plies} random plies each)...", flush=True)
    openings = [generate_opening(args.plies, rng) for _ in range(args.openings)]

    # ── Tournament ────────────────────────────────────────────────────────────
    print(f"\n{'='*65}", flush=True)
    print(f"  v20 vs v19 — {args.openings} openings × 2 colors = {args.openings*2} games", flush=True)
    print(f"  Depth: {args.depth}   Opening plies: {args.plies}", flush=True)
    print(f"{'='*65}", flush=True)
    print(f"{'Game':>5}  {'Opening':>7}  {'v20 Color':>9}  {'Result':>8}  "
          f"{'v20 Score':>9}  {'W':>4} {'D':>4} {'L':>4}  Elapsed", flush=True)
    print(f"{'-'*65}", flush=True)

    v20_score = 0.0
    wins = draws = losses = 0
    start_time = time.time()
    game_num = 0

    for i, fen in enumerate(openings):
        for v20_is_white in [True, False]:
            game_num += 1
            if v20_is_white:
                white_e, black_e = v20, v19
                color_str = "White"
            else:
                white_e, black_e = v19, v20
                color_str = "Black"

            result_white = play_game(white_e, black_e, fen, args.depth, args.moves)

            # Score from v20's perspective
            if v20_is_white:
                v20_result = result_white
            else:
                v20_result = 1.0 - result_white

            v20_score += v20_result

            if v20_result == 1.0:
                wins += 1; res_str = "Win"
            elif v20_result == 0.5:
                draws += 1; res_str = "Draw"
            else:
                losses += 1; res_str = "Loss"

            elapsed = time.time() - start_time
            total_games = args.openings * 2
            eta = elapsed / game_num * (total_games - game_num) if game_num > 0 else 0

            print(f"{game_num:>5}  {i+1:>7}  {color_str:>9}  {res_str:>8}  "
                  f"{v20_score:>9.1f}  {wins:>4} {draws:>4} {losses:>4}  "
                  f"{elapsed/3600:.2f}h  ETA {eta/3600:.2f}h", flush=True)

            v20.new_game()
            v19.new_game()

    # ── Final summary ─────────────────────────────────────────────────────────
    total = game_num
    elapsed = time.time() - start_time
    pct = 100 * v20_score / total if total > 0 else 0

    print(f"\n{'='*65}", flush=True)
    print(f"  FINAL RESULT — v20 vs v19  ({total} games)", flush=True)
    print(f"  v20: {wins}W / {draws}D / {losses}L  =  {v20_score:.1f}/{total}  ({pct:.1f}%)", flush=True)
    print(f"  Elapsed: {elapsed/3600:.2f}h", flush=True)
    print(f"{'='*65}", flush=True)

    v20.quit()
    v19.quit()


if __name__ == "__main__":
    main()
